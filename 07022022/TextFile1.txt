Наследование
Тип связи между объектами
Используется для создания полиморфизма - различных реализаций одного интерфейса
Для создания наследника используется оператор ":" - расширение области видимости
В С# родительский класс может быть только один
Наследование по умолчанию public
Проблема:
При объявлении в наследнике поля с таким же именем, как у родителя, используется "ближайшее" - у наследника
Если не объявлять, то используется родительское. 
Побочное действие - изменение поведения кода из-за изменений в другой части кода (не в этом коде)

!! При обращении к элементам классов РЕКОМЕНДУЕТСЯ указывать префикс "base." или "this." для снятия побочного действия

Перегрузка операторов


Способ изменить поведение обычных операторов для наших типов данных (для тех типов данных, для которых они напрямую не предусмотрены).
Т.к. C# объектно ориентирован, процедур/функций нет , и все операторы - члены классов. 
Реализуются статически - принадлежат классу, но не объекту (объект им пользуется, но принадлежит классу)
В параметрах оператора указываются все "участники"
!! Особенность C#: некоторые операторы обязательно перегружать парами:
"==" - "!="
"< " - " >"


Свойства - "гибрид" поля с акссесорами, для которого используются обычные операторы ( = для сеттеров, имя для геттеров)
{								 =		{ private int _prop
	public int prop {get; set;}	 =		  public getProp()
}								 =		  public setProp() }

obj.prop = 10					 =		  obj.setProp(10)
cw(obj.prop)					 =		  cw(obj.getProp()) 

Исключения (exceptions)
Это механизм управления порядком выполнения кода позволяющий прервать выполнение и перейти в другую "точку"
Для изменения порядка хода программы исключение "выбрасывают" - throw new Exception("Message")
После этого исключение начинает "всплывать" - двигаться из блока в блок до того, как будет "поймано". Если нет, то разрушает всю программу - 
"Программа выполнила недопустимую операцию". Считается ОЧЕНЬ плохим подходом, когда исключение может дойти до "верха" программы.
Общее оформление:
try {	// блок, в котором возможен "выброс"
	код1
	if(...) throw new Тип3("Message 1")   // выброс исключения типа 1 - остановка выполнения и начало "всплытия" исключения
	код	2									      
	if(...) throw new Тип2("Message 2")
	код3
	if(...) throw new Тип3("Message 3")
	код4
}
catch(Тип1 ex) {	// в этот блок перейдет управление если будет выброшено исключение типа 1 
	обработка исключений типа 1 
	return;
}	 												
catch(Тип2 ex) { обработка исключений типа 2 }
finally { 
	этот блок выполнится в любом случае, даже если в catch будет return 
}	
КОД

Если выбрасывает исключение Тип1:
	код1 - обработка1 - finally - return
Если выбрасывает исключение Тип2:
	код1 - код2 - обработка2 - finally - КОД
Если нет исключений
	код1 - код2 - код3 - код4 - finally - КОД
Если выбрасывается исключение Тип3:
	код1 - код2 - код3 - "дальнейшее всплытие", если нет внешних catch, то разрушается программа


В платформе .NET заложена своя  система типов исключений, а также многие методы объектов .NET выбрасывают исключения при своей работе
--------------------------------------------------------
Проект "ММ"
Игровое поле (мир)
на нем персонажи 
Случайным образом выбираются два персонажа и они сражаются

[поле]-агрегация()-[персонаж] 
					  | (наследование (расширение))
			 [Воин] [Эльф] [Маг]