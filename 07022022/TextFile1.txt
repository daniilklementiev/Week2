Наследование
Тип связи между объектами
Используется для создания полиморфизма - различных реализаций одного интерфейса
Для создания наследника используется оператор ":" - расширение области видимости
В С# родительский класс может быть только один
Наследование по умолчанию public
Проблема:
При объявлении в наследнике поля с таким же именем, как у родителя, используется "ближайшее" - у наследника
Если не объявлять, то используется родительское. 
Побочное действие - изменение поведения кода из-за изменений в другой части кода (не в этом коде)

!! При обращении к элементам классов РЕКОМЕНДУЕТСЯ указывать префикс "base." или "this." для снятия побочного действия

Перегрузка операторов


Способ изменить поведение обычных операторов для наших типов данных (для тех типов данных, для которых они напрямую не предусмотрены).
Т.к. C# объектно ориентирован, процедур/функций нет , и все операторы - члены классов. 
Реализуются статически - принадлежат классу, но не объекту (объект им пользуется, но принадлежит классу)
В параметрах оператора указываются все "участники"
!! Особенность C#: некоторые операторы обязательно перегружать парами:
"==" - "!="
"< " - " >"


Свойства - "гибрид" поля с акссесорами, для которого используются обычные операторы ( = для сеттеров, имя для геттеров)
{								 =		{ private int _prop
	public int prop {get; set;}	 =		  public getProp()
}								 =		  public setProp() }

obj.prop = 10					 =		  obj.setProp(10)
cw(obj.prop)					 =		  cw(obj.getProp()) 
--------------------------------------------------------
Проект "ММ"
Игровое поле (мир)
на нем персонажи 
Случайным образом выбираются два персонажа и они сражаются

[поле]-агрегация()-[персонаж] 
					  | (наследование (расширение))
			 [Воин] [Эльф] [Маг]